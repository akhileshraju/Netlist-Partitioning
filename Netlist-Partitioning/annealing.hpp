//
//  annealing.hpp
//  Netlist-Partitioning
//
//  Created by Akhilesh Raju on 12/2/16.
//  Copyright Â© 2016 Akhilesh Raju. All rights reserved.
//

#ifndef annealing_hpp
#define annealing_hpp

#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>

// For the linked list to be used in the adjacency list
struct node {
    unsigned int value;
    unsigned int weight; // Weight provision made but NOT USED
    node *next;
};

// Handles all functions and data members required for successful execution of the SA algorithm
class simulatedAnnealing {
    double T;                           // Current temperature
    double Tf;                          // Freezing temperature
    double alpha;                       // Temperature decrease factor alpha
    int gain;                           // Variable that indicates the gain for a particular pair exchange
    unsigned int finalCost;             // Final cutset cost
    unsigned int steps;                 // Number of steps used by the for loop in SA
    unsigned int noOfCells;             // Total no of cells as given from the benchmark
    unsigned int noOfNets;              // Total no of nets obtained from the benchmark
    unsigned int index1;                // The first randomly generated index used by the perturb function
    unsigned int index2;                // The second randomly generated index used by the perturb function
    const double e = 2.71828182;        // e = exponential constant used by the acceptMove()
    std::vector<node *> adjList;             // Adjacency list - a vector of pointers of struct node declared earlier
    std::vector<int> eValues;                // Contains the number of external connections for individual nodes
    std::vector<int> iValues;                // Contains the number of internal connections for individual nodes
    std::vector<int> dValues;                // Contains the D value i.e. E - I values for individual nodes
    std::vector<unsigned int> partition1;    // Partition 1
    std::vector<unsigned int> partition2;    // Partition 2
    
    // Function to set T, Tf, alpha and steps based on the number of cells obtained from the benchmark
    void setParameters();
    // Function to add nodes into the adjacency list
    void addToAdjList(unsigned int data[2]);
    // NOTE -> If a value of '0' is passed to any of the below 3 functions; they will generate values for
    // all nodes. This is only used during the initialization stage of the program
    // Function to update the external connections of individual nodes
    void updateEValue(unsigned int nodeNumber);
    // Function to update the internal connections of individual nodes
    void updateIValue(unsigned int nodeNumber);
    // Function to update the D value of nodes
    void updateDValues(unsigned int nodeNumber);
    // Function that uses rand() to generate 2 random indices to swap
    void perturb();
    // Function to calculate the gain after a pair is swapped between partitions
    void calculateGain();
    // Function that decides wether the swap should be accepted or rejected
    bool acceptMove();
    // Computes the final cost after the SA algorithm has finished
    void computeFinalCost();
    // Writes results to a file
    // 1st line in the file contains the final cutset cost as generated by the SA algorithm
    // 2nd line lists the first partition
    // 3rd line lists the second partition
    void writeResult(std::string fileName);
    
public:
    // Constructor that is responsible for building the adjacency list, the initial partitions
    // setting the parameters for the algorithm and computing the initial E, I and D values
    simulatedAnnealing(std::string fileName);
    // User called function to perform the annealing operation. Once it completes it calls the
    // writeResult() to output to a text file
    void performAnnealing(std::string fileName);
    // Functions for printing the various data structures onto the console
    void printAdjList();
    void printPartitions();
    void printEvalues();
    void printIvalues();
    void printDvalues();
};

#endif /* annealing_hpp */
